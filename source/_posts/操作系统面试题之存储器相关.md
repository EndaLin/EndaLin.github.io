---
title: 操作系统面试题之存储器相关
copyright: true
date: 2019-11-06 14:39:19
tags: 操作系统
---

# 存储器的层次结构

寄存器、高速缓存、主存储器、磁盘缓存、固定磁盘、可移动的存储介质

# 逻辑地址和物理地址

用户能看到的程序代码、变量、堆找的地址称之为**逻辑地址**，它们所在的实际内存区域实际地址是**物理地址**

## 将逻辑地址和物理地址分开的好处
- 实现内存隔离
- 实现进程和内核保护

# 内核空间与用户空间

**内核空间：** 程序地址空间中安排给操作系统使用的部分，又称之为虚拟存储器

**用户空间：** 程序地址空间中安排给用户程序使用的部分，又称为用户虚拟存储器

# 分页存储管理和页表

- 把装入模块（即链接后的可执行程序）切分为一系列等长的片段，每个片段称为一个页面(页面长度为512B、1KB、2KB、4KB等，小于动态分区的很多碎片），页号依次为0、1、2、…，(具有n-1个页面的进程大小是多少字节)
- 也把系统物理内存划分为一系列等长的片段，每个片段称为一个物理块（或一个页帧），物理块长度与页面长度相同,块号为0、1、2、…
- 用户程序运行时，操作系统将其各个页面装载到一系列任意的物理块（地址可能不连续）

## 进程页号与物理页号的管理

页表：通常使用数组来组织页表，页表并不保存页号，只保存物理块号。

## 在分页系统中，地址转换的流程
- 从逻辑地址中提取页号
- 根据页号，查询页表，找到对应的物理块号
- 用物理块号和块内的地址定位到对应的数据

![image.png](https://upload-images.jianshu.io/upload_images/13918038-a92e7c381e3e68f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 提高地址转换效率

由于页表保存在内存中，所以1 次内存存取的操作需要两次访存开销（一次查页表，一次读取内存本身）， 会降低系统效率

**解决方案：**
- 将经常使用的页表项放到**快表** 中，快表比内存快5 倍以上
- MMU 执行地址转换时，在快表和页表中查找物理块号，若快表命中，则立即获取物理块号，若快表不命中，再到主存页表中查找
- 由于程序具有局部性特征，设置少量快表项，即可大幅提高地址转换速度

## 空闲页表管理
- 位示图法
- 链表法
- 多级页表法

# 分段存储管理

## 基本思想

- 把程序按照内容或者函数分成段，每段有自己的名字，每段各有一个连续的地址空间
- 段式管理可以将那些经常访问的段驻留在内存，将那些不常访问到的放到外存中

## 段管理

为了能找到每个逻辑段对应的物理内存的中分区的位置，系统为每个进程建立了一个段映射表，简称“段表”

每个段在段表中均有一项，段表项中包括如下内容：段号、段的长度、段在内存中的起始地址

![image.png](https://upload-images.jianshu.io/upload_images/13918038-a8e62726d76d69b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 段页式存储管理方式

地址空间划分：作业的地址空间仍按其逻辑结构分段。每个段又被进一步分成若干大小相同的页面。内存空间则分成与页面大小相等的物理块

# 虚拟存储器

## 程序运行特性分析

大型复杂程序通常由很多模块构成，其运行过程有一些特性：有时一次执行过程仅少量模块被调用执行(如powerpoint、matlab、QQ)，或某段时间内仅少量模块被调用执行(如ppt文字录入时)，把大量没有用到的程序代码载入主存，是一种浪费。

某段时间内仅将部分部分代码、数据模块载入内存，可提高内存利用率，缓解内存不足的问题，传统方法有：
- 覆盖(重叠，overlay)：将不会同时执行的模块装载到同一个内存块，但需预先给出模块间调用关系，增加程序员负担。
- 动态加载(dynamic loading)：不常用的程序模块以动态链接库(.DLL，.so)方式保存在外存，在需要调用它们的地方用动态装载函数(LoadLibrary, dlopen)加载，虽然可以实现模块共享，但大量的使用这些函数也给程序员带来负担。

最好是把这些模块选择与加载工作全部交给操作系统：由OS根据系统空闲内存状况，灵活决定将哪些模块加载到内存，哪些模块留在外存，并自动完成模块加载工作。

## 虚拟存储器的基本思想
- 把辅存的一部分拿来虚拟成实体存储器
- 部分加载方法：最近需要访问的代码、需要访问的数据加载到物理内存中，其余数据保存在虚拟存储器中（外存）
- 虚拟存储器技术通常与分页式存储管理（paging)或分段式存储管理联合使用

# 请求分页系统存储管理

- 应用程序在运行之前，仅须将那些当前要运行的少数页面或段，先装入内存便可运行，其余部分暂留在外存（虚拟存储器）上。
- 程序在运行时，如果它所要访问的页已调入内存，便可继续执行；但如果程序所要访问的页尚未调入内存（称为缺页），便发出缺页中断请求，由OS利用指定页面调入内存。
- 若此时内存已满，无法再装入新页，OS应将内存中暂时不用的页调至外存（虚拟存储器）上，腾出页帧后，再所需页面调入内存（页面置换），使程序得以继续执行

## 页表修改
状态为P:判断页表是在内存中还是在外存中
![image.png](https://upload-images.jianshu.io/upload_images/13918038-e14f6af645c23cd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 缺页中断处理过程

![image.png](https://upload-images.jianshu.io/upload_images/13918038-3d48f04d30362c70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 页面置换算法

请求分页存储系统可用内存不足时，若调入新的页面，就需选择一个内存中被替换页面，将新页面的内容写入该页面所在物理块。

### 最佳置换算法OPT： 总是选择以后永不使用的，或许是在最长(未来)时间内不再被访问的页面，进行替换
![image.png](https://upload-images.jianshu.io/upload_images/13918038-18c66469c9bb361b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 先进先出页面置换算法（FIFO）：当需要调入新的页面，但无可用空闲物理块时，总是选择在内存中驻留时间最长的页并予以淘汰，用腾出的物理块来载入新的页面

先进先出算法没有考虑程序执行的**局部性特征**  
**时间局部性**：如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问，像循环结构  
**空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，象数组结构

![image.png](https://upload-images.jianshu.io/upload_images/13918038-a152d87e8c8c479f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### LRU 置换算法（淘汰最久未使用的页面）
据程序局部性原理，认为程序最近一段时间内经常访问的地址，也会是不久将来经常访问的地址，认为最后一次访问时间距离当前时间最久的页面，是不久将来访问可能性比较小的页面。  
硬件对该算法的支持：移位寄存器、堆栈法、计数器法

虽然LRU算法较好，但要求较多的硬件支持，实现代价（页表存储开销、地址转换过程开销）高，阻碍其应用推广。实际应用中大多采用性能下降不大但实现代价小的LRU近似算法，Clock置换算法是典型代表

### Clock 置换算法

![image.png](https://upload-images.jianshu.io/upload_images/13918038-c6741da1dc1982ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)